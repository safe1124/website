<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title data-ja="初めてのウェブサイト" data-ko="처음으로 만든 웹사이트">初めてのウェブサイト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="style.mobile.css" media="only screen and (max-width: 768px)" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <style>
    @font-face {
      font-family: 'GraphikBold';
      src: url('https://www.shiyunlu.com/fonts/graphik-bold.woff2') format('woff2');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }
    .shin-title {
      text-align: center;
      font-size: 4.5rem;
      font-family: 'GraphikBold', 'Arial Black', sans-serif;
      font-weight: bold;
      letter-spacing: 0.08em;
      margin-bottom: 32px;
      color: #222;
      line-height: 1.1;
    }
    @media (max-width: 600px) {
      .shin-title {
        font-size: 2.5rem;
      }
    }

    /* 커스텀 커서 디자인 */
    body, html {
      cursor: url('https://cdn.jsdelivr.net/gh/ionic-team/ionicons@5.5.2/src/svg/hand-left-outline.svg'), auto;
    }
    /* 예시: 위 URL을 원하는 커서 이미지로 변경 가능 (SVG/PNG/ICO 등) */
    /* PNG 예시: cursor: url('https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f44b.png'), auto; */
    /* 또는 직접 img 폴더에 커서 이미지를 두고 src="img/my-cursor.png"로 사용 가능 */

    /* 버튼 등에서 pointer 커서 유지 */
    a, button, .social-button, label, .switch {
      cursor: pointer;
    }
  </style>
  <script src="language-switcher.js"></script>
  <script src="load-nav.js" defer></script> <!-- load-nav.js 추가 -->
  <script>
    // 오버레이 애니메이션
    window.addEventListener('DOMContentLoaded', function() {
      const overlay = document.getElementById('site-overlay');
      setTimeout(() => {
        overlay.classList.add('hide');
      }, 400); // 약간의 딜레이 후 애니메이션 시작
      overlay.addEventListener('transitionend', () => {
        overlay.parentNode.removeChild(overlay);
      });
    });
  </script>
</head>
<body>
  <div id="nav-placeholder"></div> <!-- 기존 nav-menu를 placeholder로 대체 -->

  <!-- Background Canvas -->
  <canvas id="bg"></canvas>
  <!-- 오버레이 효과 -->
  <div id="site-overlay"></div>
  
  <div class="main-layout">
    <div class="content">
      
      
      <!-- 큰 동그라미 추가 -->
      <div style="display: flex; justify-content: center; align-items: center; height: 320px; margin: 40px 0;">
        <div style="
          width: 260px;
          height: 260px;
          border-radius: 50%;
          background: #fff;
          box-shadow: 0 4px 32px rgba(0,0,0,0.10);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 2rem;
          color: #bbb;
          overflow: hidden;
        ">
          <!-- 
            아래 img 태그의 src에 사용할 이미지는 
            /Users/shin/Desktop/study/img/profile.jpg 와 같이 img 폴더를 만들어 저장하세요.
            예시: <img src="img/profile.jpg" alt="프로필 이미지" style="width:100%;height:100%;object-fit:cover;">
          -->
          <img src="img/profile.JPEG" alt="프로필 이미지" style="width:100%;height:100%;object-fit:cover;">
        </div>
      </div>

      <!-- SHIN 텍스트 크게, 커스텀 폰트 적용 -->
      <div class="shin-title">
        SHIN
      </div>
      <div class="social-links">
        <a rel="noopener" href="https://www.youtube.com/@tcu_vlog2215" class="social-button youtube" target="_blank" data-ja="ユーチューブ" data-ko="유튜브">
          <i class="fab fa-youtube"></i>
          YouTube
        </a>
        <a rel="noopener" href="https://www.instagram.com/utaenaimiku" class="social-button instagram" target="_blank" data-ja="インスタグラム" data-ko="인스타그램">
          <i class="fab fa-instagram"></i>
          Instagram
        </a>
        <a rel="noopener" href="https://twitter.com/sico_sico_sico_" class="social-button twitter" target="_blank" data-ja="𝕏" data-ko="𝕏">
          <i class="fab fa-x-twitter"></i>
          𝕏
        </a>

      </div>

      <!-- 언어 토글 버튼 (선택한 언어만 표시) -->
      <div class="language-switcher">
        <span class="language-label" id="current-lang">日本語</span>
        <label class="switch">
          <input aria-label="Language Toggle" type="checkbox" id="language-toggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
    <aside class="youtube-sidebar">
      <h2 id="youtube-title" data-ja="最新のYouTube動画" data-ko="최신 YouTube 동영상">最新のYouTube動画</h2>
      <div class="youtube-videos">
        <div class="youtube-section-title" id="latest-videos" data-ja="最新動画（최신영상）" data-ko="최신 동영상（最新動画）">最新動画（최신영상）</div>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/w8iq04de_RA" title="YouTube video 1" frameborder="0" allowfullscreen></iframe>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/7kz51n1eNtc" title="YouTube video 2" frameborder="0" allowfullscreen></iframe>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/09uETkRHY8k" title="YouTube video 3" frameborder="0" allowfullscreen></iframe>
      </div>
      <a rel="noopener" href="https://www.youtube.com/@tcu_vlog2215" target="_blank" class="youtube-more" id="more-link" data-ja="もっと見る" data-ko="더 보기">もっと見る</a>
    </aside>

  </div>

  <script>
    // 時計機能
    function updateClock() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      document.getElementById('clock').textContent = `${hh}:${mm}:${ss}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    // 背景キャンバスアニメーション
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    let mouseX = 0;
    let mouseY = 0;
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // 마우스 위치 추적
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // 어두운 남색 배경 + 손전등 효과로 변경
    function drawBackground() {
      // 어두운 남색 배경
      ctx.fillStyle = "#0a1733";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 손전등(라이트) 효과
      const flashlightRadius = 500;
      const gradient = ctx.createRadialGradient(
        mouseX, mouseY, 0,
        mouseX, mouseY, flashlightRadius
      );
      gradient.addColorStop(0, "rgba(255,255,255,0.18)");
      gradient.addColorStop(0.5, "rgba(255,255,255,0.08)");
      gradient.addColorStop(1, "rgba(10,23,51,0.0)");
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, flashlightRadius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
      ctx.globalCompositeOperation = "source-over";
    }

    // 큰 원들 애니메이션
    const circles = [];
    const circleCount = 4; // 큰 원 개수 줄임
    
    class AnimatedCircle {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 3; // 속도 증가
        this.vy = (Math.random() - 0.5) * 3; // 속도 증가
        this.baseSize = Math.random() * 150 + 100; // 큰 원 크기
        this.size = this.baseSize;
        this.opacity = 0.6;
        this.hue = Math.random() * 60 + 180; // 하늘색 계열 (180-240도)
      }
      
      update() {
        // 마우스와의 거리 계산
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 마우스가 가까우면 끌어당김
        if (distance < 200) {
          const force = (200 - distance) / 200 * 0.02;
          this.vx += (dx / distance) * force;
          this.vy += (dy / distance) * force;
          this.size = this.baseSize * (1 + force * 10);
        } else {
          this.size = this.baseSize;
        }
        
        // 속도 제한
        this.vx = Math.max(-3, Math.min(3, this.vx)); // 속도 제한 증가
        this.vy = Math.max(-3, Math.min(3, this.vy)); // 속도 제한 증가
        
        // 위치 업데이트
        this.x += this.vx;
        this.y += this.vy;
        
        // 경계에서 반사
        if (this.x < -this.size/2) {
          this.x = canvas.width + this.size/2;
        } else if (this.x > canvas.width + this.size/2) {
          this.x = -this.size/2;
        }
        
        if (this.y < -this.size/2) {
          this.y = canvas.height + this.size/2;
        } else if (this.y > canvas.height + this.size/2) {
          this.y = -this.size/2;
        }
        
        // 마찰력
        this.vx *= 0.99;
        this.vy *= 0.99;
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        // 그라디언트 원
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, `hsla(${this.hue}, 80%, 50%, 0.8)`);
        gradient.addColorStop(0.7, `hsla(${this.hue}, 60%, 40%, 0.4)`);
        gradient.addColorStop(1, `hsla(${this.hue}, 40%, 30%, 0.1)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // 원들 생성
    for (let i = 0; i < circleCount; i++) {
      circles.push(new AnimatedCircle());
    }
    
    function animate() {
      // 배경 그리기
      drawBackground();
      
      // 원들 업데이트 및 그리기
      circles.forEach(circle => {
        circle.update();
        circle.draw();
      });
      
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>