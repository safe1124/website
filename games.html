<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title data-ja="ゲーム" data-ko="게임">게임 - My Website</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="style.mobile.css" media="only screen and (max-width: 768px)" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <script src="language-switcher.js"></script>
  <script src="load-nav.js" defer></script>
  <style>
    .content {
      padding: 20px;
      max-width: 1200px;
      margin: 20px auto;
      background-color: rgba(255, 255, 255, 0.9);
      border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    .game-container {
      margin-top: 30px;
      text-align: center;
    }

    .game-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      font-weight: bold;
    }

    .game-canvas {
      border: 2px solid #535353;
      background: #f7f7f7;
      display: block;
      margin: 20px auto;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
      max-width: 100%;
    }

    .game-controls {
      margin: 20px 0;
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .control-btn {
      padding: 12px 24px;
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    }

    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .control-btn:active {
      transform: translateY(0);
    }

    .score-display {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      padding: 15px;
      margin: 20px 0;
      display: flex;
      justify-content: space-around;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .score-item {
      text-align: center;
    }

    .score-label {
      font-size: 14px;
      color: #666;
      margin-bottom: 5px;
    }

    .score-value {
      font-size: 24px;
      font-weight: bold;
      color: #333;
    }

    .game-instructions {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      text-align: left;
    }

    .game-instructions h3 {
      color: #667eea;
      margin-bottom: 15px;
    }

    .game-instructions ul {
      list-style-type: none;
      padding: 0;
    }

    .game-instructions li {
      margin: 10px 0;
      padding: 8px 12px;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
    }

    @media (max-width: 768px) {
      .content {
        padding: 10px;
        margin: 10px auto;
      }
      
      .game-container {
        margin-top: 20px;
      }
      
      .game-title {
        font-size: 2em;
        margin-bottom: 15px;
      }
      
      .game-canvas {
        max-width: 100%;
        width: 100%;
        height: auto;
      }
      
      #offline-canvas {
        width: 100% !important;
        height: auto !important;
        min-height: 220px !important;
        max-width: 100%;
        border-radius: 8px;
      }
      
      #main-frame-error {
        max-width: 100%;
        margin: 0;
      }
      
      .icon.icon-offline {
        height: auto !important;
        min-height: 240px !important;
        padding: 10px;
        box-sizing: border-box;
      }
      
      .score-display {
        padding: 10px;
        margin: 15px 0;
        flex-direction: row;
        flex-wrap: wrap;
        gap: 5px;
      }
      
      .score-item {
        flex: 1;
        min-width: 90px;
      }
      
      .control-btn {
        padding: 10px 20px;
        font-size: 14px;
        margin: 5px;
      }
      
      .game-controls {
        flex-direction: column;
        gap: 10px;
      }
      
      .score-value {
        font-size: 20px;
      }
      
      .help__outer {
        flex-direction: column;
        gap: 15px;
      }
      
      .help {
        flex-direction: column;
        gap: 10px;
        align-items: center;
      }
      
      .help__key_big {
        padding: 12px 24px;
        font-size: 16px;
      }
      
      .game-instructions {
        padding: 15px;
        margin: 15px 0;
      }
      
      .game-instructions li {
        font-size: 14px;
        padding: 6px 10px;
      }
    }

    /* Chrome Dino Game Styles */
    #main-frame-error {
      position: relative;
      max-width: 600px;
      margin: 0 auto;
      background: #f7f7f7;
      border-radius: 8px;
      overflow: hidden;
    }

    .icon.icon-offline {
      width: 100%;
      height: 300px;
      background: #f7f7f7;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game__help {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: #535353;
      font-size: 18px;
      font-weight: bold;
    }

    .help__outer {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
      color: #535353;
    }

    .help {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .help__key_big {
      padding: 8px 16px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 4px;
      font-weight: bold;
    }

    .help__key_small {
      width: 30px;
      height: 30px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
    }

    .help__key_active {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    .help__keys {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .help__keys-line {
      display: flex;
      gap: 5px;
      justify-content: center;
    }

    /* Game Result Modal Styles */
    .game-result-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .game-result-modal.show {
      opacity: 1;
      visibility: visible;
    }

    .result-content {
      background: white;
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      transform: scale(0.8);
      transition: transform 0.3s ease;
    }

    .game-result-modal.show .result-content {
      transform: scale(1);
    }

    .result-title {
      font-size: 2.5em;
      margin-bottom: 20px;
      color: #333;
    }

    .result-grade {
      font-size: 4em;
      font-weight: bold;
      margin: 20px 0;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .result-stats {
      margin: 30px 0;
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
    }

    .result-stat {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      border-left: 4px solid #667eea;
    }

    .result-stat-label {
      font-size: 0.9em;
      color: #666;
      margin-bottom: 5px;
    }

    .result-stat-value {
      font-size: 1.5em;
      font-weight: bold;
      color: #333;
    }

    .grade-c {
      color: #6c757d;
    }

    .grade-b {
      color: #007bff;
    }

    .grade-a {
      color: #28a745;
    }

    .grade-s {
      background: linear-gradient(45deg, #ffd700, #ffed4e);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .grade-ss {
      background: linear-gradient(45deg, #ff0000, #ff6b6b, #ff0000);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: glow-red 2s ease-in-out infinite alternate;
    }

    .grade-sss {
      background: linear-gradient(45deg, #8b00ff, #da70d6, #9370db, #8b00ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: glow-purple 2s ease-in-out infinite alternate;
    }

    .grade-sss-plus {
      background: linear-gradient(45deg, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 300% 300%;
      animation: rainbow-glow 3s ease-in-out infinite, rainbow-flow 4s linear infinite;
    }

    .grade-z {
      background: linear-gradient(45deg, #8b0000, #cc4400, #ffaa00, #66cc00, #00aa00, #00cc66, #00aacc, #0066cc, #0000aa, #6600cc, #aa00aa, #cc0066);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      background-size: 400% 400%;
      animation: dark-rainbow-glow 2s ease-in-out infinite, dark-rainbow-flow 3s linear infinite;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
    }

    @keyframes glow-red {
      from {
        filter: drop-shadow(0 0 5px #ff0000);
      }
      to {
        filter: drop-shadow(0 0 20px #ff0000);
      }
    }

    @keyframes rainbow-glow {
      0%, 100% {
        filter: drop-shadow(0 0 10px #ff0000) drop-shadow(0 0 20px #ff0000);
      }
      16.67% {
        filter: drop-shadow(0 0 10px #ffff00) drop-shadow(0 0 20px #ffff00);
      }
      33.33% {
        filter: drop-shadow(0 0 10px #00ff00) drop-shadow(0 0 20px #00ff00);
      }
      50% {
        filter: drop-shadow(0 0 10px #00ffff) drop-shadow(0 0 20px #00ffff);
      }
      66.67% {
        filter: drop-shadow(0 0 10px #0000ff) drop-shadow(0 0 20px #0000ff);
      }
      83.33% {
        filter: drop-shadow(0 0 10px #ff00ff) drop-shadow(0 0 20px #ff00ff);
      }
    }

    @keyframes rainbow-flow {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes dark-rainbow-glow {
      0%, 100% {
        filter: drop-shadow(0 0 15px #8b0000) drop-shadow(0 0 30px #8b0000) drop-shadow(0 0 45px #8b0000);
      }
      16.67% {
        filter: drop-shadow(0 0 15px #ffaa00) drop-shadow(0 0 30px #ffaa00) drop-shadow(0 0 45px #ffaa00);
      }
      33.33% {
        filter: drop-shadow(0 0 15px #00aa00) drop-shadow(0 0 30px #00aa00) drop-shadow(0 0 45px #00aa00);
      }
      50% {
        filter: drop-shadow(0 0 15px #00aacc) drop-shadow(0 0 30px #00aacc) drop-shadow(0 0 45px #00aacc);
      }
      66.67% {
        filter: drop-shadow(0 0 15px #0000aa) drop-shadow(0 0 30px #0000aa) drop-shadow(0 0 45px #0000aa);
      }
      83.33% {
        filter: drop-shadow(0 0 15px #aa00aa) drop-shadow(0 0 30px #aa00aa) drop-shadow(0 0 45px #aa00aa);
      }
    }

    @keyframes dark-rainbow-flow {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes glow-purple {
      from {
        filter: drop-shadow(0 0 5px #8b00ff);
      }
      to {
        filter: drop-shadow(0 0 20px #8b00ff);
      }
    }

    .result-stats {
      margin: 30px 0;
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
    }

    .result-stat {
      display: flex;
      justify-content: space-between;
      margin: 10px 0;
      font-size: 1.2em;
    }

    .result-stat-label {
      color: #666;
    }

    .result-stat-value {
      font-weight: bold;
      color: #333;
    }

    .result-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-top: 30px;
    }

    .result-btn {
      padding: 12px 24px;
      border: none;
      border-radius: 25px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .result-btn-primary {
      background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .result-btn-secondary {
      background: #6c757d;
      color: white;
    }

    .result-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    @media (max-width: 768px) {
      .result-content {
        padding: 30px 20px;
        margin: 20px;
        max-width: 90%;
      }

      .result-title {
        font-size: 2em;
        margin-bottom: 15px;
      }

      .result-grade {
        font-size: 3em;
        margin: 15px 0;
      }

      .result-stats {
        margin: 20px 0;
        gap: 10px;
      }

      .result-stat {
        padding: 12px;
      }

      .result-stat-label {
        font-size: 0.8em;
      }

      .result-stat-value {
        font-size: 1.3em;
      }

      .result-buttons {
        flex-direction: column;
        gap: 10px;
      }

      .result-btn {
        padding: 15px 20px;
        font-size: 16px;
        width: 100%;
      }
    }
  </style>
</head>
<body style="background:#FFF9E3;">
  <div id="nav-placeholder"></div>
    <div class="content">
      <h1 data-ja="ゲーム" data-ko="게임">게임</h1>
      
      <div class="game-container">
        <h2 class="game-title" data-ja="ラスクゲーム" data-ko="러스크게임">ラスクゲーム</h2>
        
        <div class="score-display">
          <div class="score-item">
            <div class="score-label" data-ja="現在のスコア" data-ko="현재 점수">현재 점수</div>
            <div class="score-value" id="current-score">0</div>
          </div>
          <div class="score-item">
            <div class="score-label" data-ja="最高スコア" data-ko="최고 점수">최고 점수</div>
            <div class="score-value" id="high-score">0</div>
          </div>
          <div class="score-item">
            <div class="score-label" data-ja="ゲーム時間" data-ko="게임 시간">게임 시간</div>
            <div class="score-value" id="game-time">0초</div>
          </div>
        </div>

        <div id="main-frame-error" class="interstitial-wrapper">
          <div id="main-content">
            <div class="icon icon-offline" alt="">
              <canvas id="offline-canvas" width="600" height="300"></canvas>
            </div>
            <div class="game__help">
             
            </div> 
          </div>
        </div>

        <div class="game-controls">
          <button class="control-btn" id="start-btn" data-ja="スタート" data-ko="시작">시작</button>
          <button class="control-btn" id="pause-btn" data-ja="一時停止" data-ko="일시정지">일시정지</button>
          <button class="control-btn" id="reset-btn" data-ja="リセット" data-ko="리셋">리셋</button>
        </div>

        <div class="help__outer">
          <div class="help">
            <div class="help__space" data-ja="使用する" data-ko="사용하기">사용하기</div>
            <div class="help__keys">
              <div class="help__keys-line">
                <div class="help__key_small help__key_active">↑</div>
              </div>
              <div class="help__keys-line">
                <div class="help__key_small">←</div>
                <div class="help__key_small help__key_active">↓</div>
                <div class="help__key_small">→</div>
              </div>
            </div>
            <div class="help__space" data-ja="または" data-ko="또는">또는</div>
            <span class="help__key_big help__key_active" data-ja="スペース" data-ko="스페이스">스페이스</span>
          </div>
        </div>

        <div class="game-instructions">
          <h3 data-ja="遊び方" data-ko="게임 방법">게임 방법</h3>
          <ul>
            <li data-ja="スペースキーまたは上矢印でジャンプ" data-ko="스페이스키 또는 위쪽 화살표로 점프">스페이스키 또는 위쪽 화살표로 점프</li>
            <li data-ja="下矢印でしゃがみ" data-ko="아래쪽 화살표로 구부리기">아래쪽 화살표로 구부리기</li>
            <li data-ja="障害物にぶつからないように注意！" data-ko="장애물에 부딪히지 않도록 주의!">장애물에 부딪히지 않도록 주의!</li>
            <li data-ja="時間が経つと速度が上がります" data-ko="시간이 지나면 속도가 빨라집니다">시간이 지나면 속도가 빨라집니다</li>
            <li data-ja="ラスクを集めて50,000-100,000点をゲット！" data-ko="라스크를 모아서 50,000-100,000점을 획득!">라스크를 모아서 50,000-100,000점을 획득!</li>
            <li data-ja="時間ボーナス: 10秒まで初当10点, 20秒まで初当100点, 30秒まで初当1,000点..." data-ko="시간 보너스: 10초까지 초당 10점, 20초까지 초당 100점, 30초까지 초당 1,000점...">시간 보너스: 10초까지 초당 10점, 20초까지 초당 100점, 30초까지 초당 1,000점, 40초까지 초당 10,000점, 50초까지 초당 100,000점, 51초 이후 초당 1,000,000점!</li>
          </ul>
          
          <h3 data-ja="グレードシステム" data-ko="등급 시스템">등급 시스템</h3>
          <ul>
            <li data-ja="C級: 0-100,000点" data-ko="C급: 0-100,000점">C급: 0-100,000점</li>
            <li data-ja="B級: 100,001-300,000点" data-ko="B급: 100,001-300,000점">B급: 100,001-300,000점</li>
            <li data-ja="A級: 300,001-500,000点" data-ko="A급: 300,001-500,000점">A급: 300,001-500,000점</li>
            <li data-ja="S級: 500,001-1,000,000点" data-ko="S급: 500,001-1,000,000점">S급: 500,001-1,000,000점</li>
            <li data-ja="SS級: 1,000,001-3,000,000点" data-ko="SS급: 1,000,001-3,000,000점">SS급: 1,000,001-3,000,000점</li>
            <li data-ja="SSS級: 3,000,001-10,000,000点" data-ko="SSS급: 3,000,001-10,000,000점">SSS급: 3,000,001-10,000,000점</li>
            <li data-ja="SSS+級: 10,000,001-25,000,000点 (レインボーエフェクト)" data-ko="SSS+급: 10,000,001-25,000,000점 (무지개 효과)">SSS+급: 10,000,001-25,000,000점 (무지개 효과)</li>
            <li data-ja="Z級: 25,000,001点以上 (ダークレインボーエフェクト)" data-ko="Z급: 25,000,001점 이상 (다크 무지개 효과)">Z급: 25,000,001점 이상 (다크 무지개 효과)</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Game Result Modal -->
    <div id="game-result-modal" class="game-result-modal">
      <div class="result-content">
        <h2 class="result-title" data-ja="ゲーム終了！" data-ko="게임 종료!">게임 종료!</h2>
        <div class="result-grade" id="result-grade">C</div>
        
        <div class="result-stats">
          <div class="result-stat">
            <div class="result-stat-label" data-ja="最終スコア" data-ko="최종 점수">최종 점수</div>
            <div class="result-stat-value" id="final-score">0</div>
          </div>
          <div class="result-stat">
            <div class="result-stat-label" data-ja="生存時間" data-ko="생존 시간">생존 시간</div>
            <div class="result-stat-value" id="survival-time">0秒</div>
          </div>
          <div class="result-stat">
            <div class="result-stat-label" data-ja="獲得ラスク" data-ko="획득 라스크">획득 라스크</div>
            <div class="result-stat-value" id="rusks-collected">0個</div>
          </div>
        </div>

        <div class="result-buttons">
          <button class="result-btn result-btn-primary" id="play-again-btn" data-ja="もう一度プレイ" data-ko="다시 플레이">다시 플레이</button>
          <button class="result-btn result-btn-secondary" id="close-result-btn" data-ja="閉じる" data-ko="닫기">닫기</button>
        </div>
      </div>
    </div>
  </main>

  <script>
    // Chrome Dino Game Implementation
    class DinoGame {
      constructor() {
        this.canvas = document.getElementById('offline-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.gameState = 'stopped'; // 'running', 'paused', 'stopped', 'gameOver'
        this.score = 0;
        this.highScore = localStorage.getItem('dinoHighScore') || 0;
        this.gameSpeed = 6;
        this.gravity = 0.6;
        this.jumpPower = -15;
        this.gameStartTime = 0;
        this.lastTimeScoreUpdate = 0;
        
        this.dino = {
          x: 50,
          y: 200,
          width: 40,
          height: 40,
          velocityY: 0,
          jumping: false,
          ducking: false
        };
        
        this.obstacles = [];
        this.bonusItems = [];
        this.clouds = [];
        this.ground = this.canvas.height - 50;
        this.lastObstacle = 0;
        this.lastBonus = 0;
        this.rusksCollected = 0; // Track collected rusks
        
        // Load character image
        this.characterImage = new Image();
        this.characterImage.src = 'img/games/character.png';
        this.imageLoaded = false;
        
        // Load rusk bonus item image
        this.ruskImage = new Image();
        this.ruskImage.src = 'img/games/rusk.png';
        this.ruskImageLoaded = false;
        
        this.characterImage.onload = () => {
          this.imageLoaded = true;
        };
        
        this.ruskImage.onload = () => {
          this.ruskImageLoaded = true;
        };
        
        this.init();
      }
      
      init() {
        this.adjustCanvasSize();
        this.adjustDinoSize();
        this.dino.y = this.ground - this.dino.height;
        this.updateDisplay();
        this.generateClouds();
        this.bindEvents();
        this.gameLoop();
      }
      
      adjustDinoSize() {
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
          // Adjust dino size for mobile
          const scale = this.canvas.width / 600; // Scale based on canvas width
          this.dino.width = Math.max(30, Math.floor(40 * scale));
          this.dino.height = Math.max(30, Math.floor(40 * scale));
          this.dino.x = Math.floor(this.canvas.width * 0.083); // 8.3% from left
          
          // Adjust jump power based on canvas height
          this.jumpPower = -Math.max(12, Math.floor(this.canvas.height * 0.055)); // Proportional to canvas height
        } else {
          this.dino.width = 40;
          this.dino.height = 40;
          this.dino.x = 50;
          this.jumpPower = -15; // Default jump power for desktop
        }
      }
      
      adjustCanvasSize() {
        const container = this.canvas.parentElement;
        const containerWidth = container.clientWidth;
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
          // Mobile: use wider aspect ratio for better gameplay
          const availableWidth = Math.min(containerWidth - 20, window.innerWidth - 40);
          const mobileAspectRatio = 1.8; // Slightly less wide than desktop (1.8:1 vs 2:1)
          
          this.canvas.width = availableWidth;
          this.canvas.height = Math.max(availableWidth / mobileAspectRatio, 220); // Min height 220px for mobile
          
          // Ensure canvas fits in viewport but allow more vertical space
          if (this.canvas.height > window.innerHeight * 0.45) {
            this.canvas.height = Math.floor(window.innerHeight * 0.45);
            this.canvas.width = this.canvas.height * mobileAspectRatio;
          }
          
          // Ensure minimum dimensions for playability
          if (this.canvas.height < 220) {
            this.canvas.height = 220;
            this.canvas.width = this.canvas.height * mobileAspectRatio;
          }
        } else {
          // Desktop: use default size
          this.canvas.width = 600;
          this.canvas.height = 300;
        }
        
        // Update ground position based on new canvas height - more space at bottom
        this.ground = this.canvas.height - Math.floor(this.canvas.height * 0.2); // Ground at ~80% of canvas height
      }
      
      bindEvents() {
        document.addEventListener('keydown', (e) => {
          if (e.code === 'Space' || e.code === 'ArrowUp') {
            e.preventDefault();
            if (this.gameState === 'running') {
              this.jump();
            } else if (this.gameState === 'stopped') {
              this.startGame();
            } else if (this.gameState === 'gameOver') {
              // Check if modal is visible
              const modal = document.getElementById('game-result-modal');
              if (!modal.classList.contains('show')) {
                this.startGame();
              }
            }
          } else if (e.code === 'ArrowDown') {
            if (this.gameState === 'running') {
              this.duck(true);
            }
          } else if (e.code === 'Escape') {
            // Close modal with Escape key
            const modal = document.getElementById('game-result-modal');
            if (modal.classList.contains('show')) {
              this.hideResultModal();
            }
          }
        });
        
        document.addEventListener('keyup', (e) => {
          if (e.code === 'ArrowDown') {
            this.duck(false);
          }
        });
        
        document.getElementById('start-btn').addEventListener('click', () => {
          if (this.gameState === 'stopped' || this.gameState === 'gameOver') {
            this.startGame();
          } else if (this.gameState === 'paused') {
            this.resumeGame();
          }
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
          if (this.gameState === 'running') {
            this.pauseGame();
          }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
          this.resetGame();
        });
        
        // Touch events for mobile
        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          if (this.gameState === 'running') {
            this.jump();
          } else if (this.gameState === 'stopped' || this.gameState === 'gameOver') {
            this.startGame();
          }
        });
        
        // Window resize event
        window.addEventListener('resize', () => {
          this.adjustCanvasSize();
          this.adjustDinoSize();
          this.dino.y = this.ground - this.dino.height;
        });

        // Result modal event listeners
        document.getElementById('play-again-btn').addEventListener('click', () => {
          this.hideResultModal();
          this.startGame();
        });

        document.getElementById('close-result-btn').addEventListener('click', () => {
          this.hideResultModal();
        });

        // Close modal when clicking outside
        document.getElementById('game-result-modal').addEventListener('click', (e) => {
          if (e.target.id === 'game-result-modal') {
            this.hideResultModal();
          }
        });
      }
      
      startGame() {
        this.gameState = 'running';
        this.score = 0;
        this.gameSpeed = 6;
        this.obstacles = [];
        this.bonusItems = [];
        this.lastObstacle = 0;
        this.lastBonus = 0;
        this.rusksCollected = 0; // Reset rusk counter
        this.gameStartTime = Date.now();
        this.lastTimeScoreUpdate = Date.now();
        this.dino.y = this.ground - this.dino.height;
        this.dino.velocityY = 0;
        this.dino.jumping = false;
        this.dino.ducking = false;
        this.updateDisplay();
      }
      
      pauseGame() {
        this.gameState = 'paused';
      }
      
      resumeGame() {
        this.gameState = 'running';
      }
      
      resetGame() {
        this.gameState = 'stopped';
        this.score = 0;
        this.gameSpeed = 6;
        this.obstacles = [];
        this.bonusItems = [];
        this.lastObstacle = 0;
        this.lastBonus = 0;
        this.gameStartTime = 0;
        this.lastTimeScoreUpdate = 0;
        this.dino.y = this.ground - this.dino.height;
        this.dino.velocityY = 0;
        this.dino.jumping = false;
        this.dino.ducking = false;
        this.updateDisplay();
      }
      
      jump() {
        if (!this.dino.jumping) {
          this.dino.velocityY = this.jumpPower;
          this.dino.jumping = true;
        }
      }
      
      duck(ducking) {
        this.dino.ducking = ducking;
      }
      
      updateTimeScore() {
        if (this.gameState !== 'running') return;
        
        const currentTime = Date.now();
        const gameTimeSeconds = Math.floor((currentTime - this.gameStartTime) / 1000);
        
        // Check if a second has passed
        if (currentTime - this.lastTimeScoreUpdate >= 1000) {
          let pointsPerSecond = 0;
          
          // 시간 구간별 점수 계산
          if (gameTimeSeconds <= 10) {
            pointsPerSecond = 10; // 1~10초: 초당 10점
          } else if (gameTimeSeconds <= 20) {
            pointsPerSecond = 100; // 11~20초: 초당 100점
          } else if (gameTimeSeconds <= 30) {
            pointsPerSecond = 1000; // 21~30초: 초당 1000점
          } else if (gameTimeSeconds <= 40) {
            pointsPerSecond = 10000; // 31~40초: 초당 10000점
          } else if (gameTimeSeconds <= 50) {
            pointsPerSecond = 100000; // 41~50초: 초당 100000점
          } else {
            pointsPerSecond = 1000000; // 51초 이후: 초당 1000000점
          }
          
          this.score += pointsPerSecond;
          this.lastTimeScoreUpdate = currentTime;
        }
      }
      
      update() {
        if (this.gameState !== 'running') return;
        
        // Update time score
        this.updateTimeScore();
        
        // Update dino physics
        this.dino.velocityY += this.gravity;
        this.dino.y += this.dino.velocityY;
        
        // Ground collision
        if (this.dino.y >= this.ground - this.dino.height) {
          this.dino.y = this.ground - this.dino.height;
          this.dino.velocityY = 0;
          this.dino.jumping = false;
        }
        
        // Generate obstacles
        if (Date.now() - this.lastObstacle > 1500 + Math.random() * 1000) {
          this.generateObstacle();
          this.lastObstacle = Date.now();
        }
        
        // Generate bonus items (twice as frequent now)
        if (Date.now() - this.lastBonus > 1500 + Math.random() * 1000) {
          this.generateBonusItem();
          this.lastBonus = Date.now();
        }
        
        // Update obstacles
        this.obstacles.forEach((obstacle, index) => {
          obstacle.x -= this.gameSpeed;
          if (obstacle.x + obstacle.width < 0) {
            this.obstacles.splice(index, 1);
            this.score += 10;
          }
        });
        
        // Update bonus items
        this.bonusItems.forEach((bonus, index) => {
          bonus.x -= this.gameSpeed;
          if (bonus.x + bonus.width < 0) {
            this.bonusItems.splice(index, 1);
          }
        });
        
        // Update clouds
        this.clouds.forEach(cloud => {
          cloud.x -= this.gameSpeed * 0.3;
          if (cloud.x + cloud.width < 0) {
            cloud.x = this.canvas.width + Math.random() * 200;
          }
        });
        
        // Check collisions
        this.checkCollisions();
        
        // Increase speed
        this.gameSpeed += 0.001;
        
        // Update score display
        this.updateDisplay();
      }
      
      generateObstacle() {
        // Only generate cactus obstacles now
        const isMobile = window.innerWidth <= 768;
        const scale = isMobile ? this.canvas.width / 600 : 1;
        
        this.obstacles.push({
          x: this.canvas.width,
          y: this.ground - Math.floor(30 * scale),
          width: Math.floor(20 * scale),
          height: Math.floor(30 * scale),
          type: 'cactus'
        });
      }
      
      generateBonusItem() {
        // Generate rusk bonus item randomly on ground or in air
        const isMobile = window.innerWidth <= 768;
        const scale = isMobile ? this.canvas.width / 600 : 1;
        
        // Air height should be proportional to canvas height
        const airHeight = Math.floor((this.canvas.height - this.ground) * 1.8); // More reasonable air height
        
        const positions = [
          { y: this.ground - Math.floor(30 * scale), height: Math.floor(30 * scale) }, // Ground level (like cactus)
          { y: this.ground - airHeight, height: Math.floor(30 * scale) }  // Air level
        ];
        const randomPosition = positions[Math.floor(Math.random() * positions.length)];
        
        this.bonusItems.push({
          x: this.canvas.width,
          y: randomPosition.y,
          width: Math.floor(30 * scale),
          height: randomPosition.height,
          type: 'rusk'
        });
      }
      
      generateClouds() {
        const cloudCount = window.innerWidth <= 768 ? 2 : 3; // Fewer clouds on mobile
        const maxY = this.canvas.height * 0.4; // Clouds in upper 40% of screen
        
        for (let i = 0; i < cloudCount; i++) {
          this.clouds.push({
            x: Math.random() * this.canvas.width,
            y: 20 + Math.random() * maxY,
            width: 40,
            height: 20
          });
        }
      }
      
      checkCollisions() {
        const dinoRect = {
          x: this.dino.x,
          y: this.dino.ducking ? this.dino.y + 20 : this.dino.y,
          width: this.dino.width,
          height: this.dino.ducking ? this.dino.height - 20 : this.dino.height
        };
        
        // Check obstacle collisions
        this.obstacles.forEach(obstacle => {
          if (this.isColliding(dinoRect, obstacle)) {
            this.gameOver();
          }
        });
        
        // Check bonus item collisions
        this.bonusItems.forEach((bonus, index) => {
          if (this.isColliding(dinoRect, bonus)) {
            const bonusScore = Math.floor(Math.random() * 50000) + 50000; // Random score between 50,000 and 100,000
            this.score += bonusScore;
            this.rusksCollected++; // Increment rusk counter
            this.bonusItems.splice(index, 1); // Remove collected bonus item
            this.updateDisplay();
          }
        });
      }
      
      isColliding(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
      }
      
      gameOver() {
        this.gameState = 'gameOver';
        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('dinoHighScore', this.highScore);
        }
        this.updateDisplay();
        
        // Show result modal after a short delay
        setTimeout(() => {
          this.showResultModal();
        }, 1000);
      }

      showResultModal() {
        const modal = document.getElementById('game-result-modal');
        const gradeElement = document.getElementById('result-grade');
        const finalScoreElement = document.getElementById('final-score');
        const survivalTimeElement = document.getElementById('survival-time');
        const rusksCollectedElement = document.getElementById('rusks-collected');

        // Calculate survival time
        const survivalTime = this.gameStartTime > 0 ? 
          Math.floor((Date.now() - this.gameStartTime) / 1000) : 0;

        // Use actual rusks collected
        const rusksCollected = this.rusksCollected;

        // Determine grade based on score
        let grade = 'C';
        let gradeClass = 'grade-c';
        
        if (this.score <= 100000) {
          grade = 'C';
          gradeClass = 'grade-c';
        } else if (this.score <= 300000) {
          grade = 'B';
          gradeClass = 'grade-b';
        } else if (this.score <= 500000) {
          grade = 'A';
          gradeClass = 'grade-a';
        } else if (this.score <= 1000000) {
          grade = 'S';
          gradeClass = 'grade-s';
        } else if (this.score <= 3000000) {
          grade = 'SS';
          gradeClass = 'grade-ss';
        } else if (this.score <= 5000000) {
          grade = 'SSS';
          gradeClass = 'grade-sss';
        } else if (this.score <= 10000000) {
          grade = 'SSS';
          gradeClass = 'grade-sss';
        } else if (this.score <= 25000000) {
          grade = 'SSS+';
          gradeClass = 'grade-sss-plus';
        } else {
          grade = 'Z';
          gradeClass = 'grade-z';
        }

        // Update modal content
        gradeElement.textContent = grade;
        gradeElement.className = `result-grade ${gradeClass}`;
        finalScoreElement.textContent = this.score.toLocaleString();
        survivalTimeElement.textContent = `${survivalTime}초`;
        rusksCollectedElement.textContent = `${rusksCollected}개`;

        // Show modal
        modal.classList.add('show');
      }

      hideResultModal() {
        const modal = document.getElementById('game-result-modal');
        modal.classList.remove('show');
      }

      getTimeBonus(seconds) {
        if (seconds <= 10) return 10;
        if (seconds <= 20) return 100;
        if (seconds <= 30) return 1000;
        if (seconds <= 40) return 10000;
        if (seconds <= 50) return 100000;
        return 1000000;
      }
      
      draw() {
        // Clear canvas
        this.ctx.fillStyle = '#f7f7f7';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw clouds
        this.ctx.fillStyle = '#c4c4c4';
        this.clouds.forEach(cloud => {
          this.drawCloud(cloud.x, cloud.y, cloud.width, cloud.height);
        });
        
        // Draw ground
        this.ctx.strokeStyle = '#535353';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(0, this.ground);
        this.ctx.lineTo(this.canvas.width, this.ground);
        this.ctx.stroke();
        
        // Draw dino
        this.drawDino();
        
        // Draw obstacles
        this.obstacles.forEach(obstacle => {
          if (obstacle.type === 'cactus') {
            this.drawCactus(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
          } else {
            this.drawBird(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
          }
        });
        
        // Draw bonus items
        this.bonusItems.forEach(bonus => {
          this.drawRusk(bonus.x, bonus.y, bonus.width, bonus.height);
        });
        
        // Draw game state text
        const isMobile = window.innerWidth <= 768;
        const fontSize = isMobile ? Math.max(12, Math.floor(this.canvas.width / 30)) : 20;
        const largeFontSize = isMobile ? Math.max(16, Math.floor(this.canvas.width / 25)) : 24;
        
        if (this.gameState === 'stopped') {
          this.drawText('스페이스바를 눌러 시작', this.canvas.width / 2, this.canvas.height / 2, `${fontSize}px Arial`, '#535353');
        } else if (this.gameState === 'paused') {
          this.drawText('일시정지', this.canvas.width / 2, this.canvas.height / 2, `${largeFontSize}px Arial`, '#535353');
        } else if (this.gameState === 'gameOver') {
          this.drawText('게임 오버!', this.canvas.width / 2, this.canvas.height / 2 - 20, `${largeFontSize}px Arial`, '#e74c3c');
          this.drawText('스페이스바를 눌러 다시 시작', this.canvas.width / 2, this.canvas.height / 2 + 20, `${fontSize}px Arial`, '#535353');
        }
      }
      
      drawDino() {
        if (this.imageLoaded) {
          // Use the loaded character image
          this.ctx.drawImage(
            this.characterImage, 
            this.dino.x, 
            this.dino.y, 
            this.dino.width, 
            this.dino.height
          );
        } else {
          // Fallback to original drawing if image not loaded
          this.ctx.fillStyle = '#535353';
          
          if (this.dino.ducking) {
            // Ducking dino (lower height)
            this.ctx.fillRect(this.dino.x, this.dino.y + 20, this.dino.width, this.dino.height - 20);
            // Eye
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(this.dino.x + 25, this.dino.y + 25, 6, 6);
            this.ctx.fillStyle = 'black';
            this.ctx.fillRect(this.dino.x + 27, this.dino.y + 27, 2, 2);
          } else {
            // Standing/jumping dino
            // Body
            this.ctx.fillRect(this.dino.x + 8, this.dino.y + 12, 24, 20);
            // Head
            this.ctx.fillRect(this.dino.x + 4, this.dino.y + 4, 20, 16);
            // Eye
            this.ctx.fillStyle = 'white';
            this.ctx.fillRect(this.dino.x + 18, this.dino.y + 8, 6, 6);
            this.ctx.fillStyle = 'black';
            this.ctx.fillRect(this.dino.x + 20, this.dino.y + 10, 2, 2);
            // Legs
            this.ctx.fillStyle = '#535353';
            this.ctx.fillRect(this.dino.x + 12, this.dino.y + 32, 4, 8);
            this.ctx.fillRect(this.dino.x + 20, this.dino.y + 32, 4, 8);
            // Arms
            this.ctx.fillRect(this.dino.x + 2, this.dino.y + 16, 8, 4);
            // Tail
            this.ctx.fillRect(this.dino.x + 32, this.dino.y + 16, 8, 4);
          }
        }
      }
      
      drawCactus(x, y, width, height) {
        this.ctx.fillStyle = '#535353';
        // Main stem
        this.ctx.fillRect(x + 8, y, 4, height);
        // Left arm
        this.ctx.fillRect(x, y + 8, 8, 8);
        this.ctx.fillRect(x, y + 8, 4, 12);
        // Right arm
        this.ctx.fillRect(x + 12, y + 12, 8, 8);
        this.ctx.fillRect(x + 16, y + 12, 4, 12);
      }
      
      drawBird(x, y, width, height) {
        this.ctx.fillStyle = '#535353';
        // Body
        this.ctx.fillRect(x + 8, y + 8, 14, 8);
        // Wings
        this.ctx.fillRect(x + 4, y + 4, 8, 4);
        this.ctx.fillRect(x + 18, y + 4, 8, 4);
        // Head
        this.ctx.fillRect(x + 22, y + 6, 6, 6);
      }
      
      drawRusk(x, y, width, height) {
        if (this.ruskImageLoaded) {
          // Use the loaded rusk image
          this.ctx.drawImage(
            this.ruskImage, 
            x, 
            y, 
            width, 
            height
          );
        } else {
          // Fallback to simple drawing if image not loaded
          this.ctx.fillStyle = '#D2691E';
          this.ctx.fillRect(x, y, width, height);
          this.ctx.fillStyle = '#F4A460';
          this.ctx.fillRect(x + 2, y + 2, width - 4, height - 4);
        }
      }
      
      drawCloud(x, y, width, height) {
        this.ctx.fillRect(x, y + 8, width * 0.8, height * 0.4);
        this.ctx.fillRect(x + width * 0.2, y, width * 0.4, height * 0.6);
        this.ctx.fillRect(x + width * 0.4, y + 4, width * 0.4, height * 0.6);
      }
      
      drawText(text, x, y, font, color) {
        this.ctx.font = font;
        this.ctx.fillStyle = color;
        this.ctx.textAlign = 'center';
        this.ctx.fillText(text, x, y);
      }
      
      updateDisplay() {
        document.getElementById('current-score').textContent = this.score;
        document.getElementById('high-score').textContent = this.highScore;
        
        // Update game time
        if (this.gameState === 'running' && this.gameStartTime > 0) {
          const gameTimeSeconds = Math.floor((Date.now() - this.gameStartTime) / 1000);
          document.getElementById('game-time').textContent = gameTimeSeconds + '초';
        } else {
          document.getElementById('game-time').textContent = '0초';
        }
      }
      
      gameLoop() {
        this.update();
        this.draw();
        requestAnimationFrame(() => this.gameLoop());
      }
    }
    
    // Initialize game when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new DinoGame();
    });
  </script>
</body>
</html>