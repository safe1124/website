<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title data-ja="初めてのウェブサイト" data-ko="처음으로 만든 웹사이트">初めてのウェブサイト</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="style.mobile.css" media="only screen and (max-width: 768px)" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <style>
    @font-face {
      font-family: 'GraphikBold';
      src: url('https://www.shiyunlu.com/fonts/graphik-bold.woff2') format('woff2');
      font-weight: bold;
      font-style: normal;
      font-display: swap;
    }
    .shin-title {
      text-align: center;
      font-size: 4.5rem;
      font-family: 'GraphikBold', 'Arial Black', sans-serif;
      font-weight: bold;
      letter-spacing: 0.08em;
      margin-bottom: 32px;
      color: #222;
      line-height: 1.1;
    }
    @media (max-width: 600px) {
      .shin-title {
        font-size: 2.5rem;
      }
    }

    /* 커스텀 커서 디자인 */
    body, html {
      cursor: url('https://cdn.jsdelivr.net/gh/ionic-team/ionicons@5.5.2/src/svg/hand-left-outline.svg'), auto;
    }
    /* 예시: 위 URL을 원하는 커서 이미지로 변경 가능 (SVG/PNG/ICO 등) */
    /* PNG 예시: cursor: url('https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f44b.png'), auto; */
    /* 또는 직접 img 폴더에 커서 이미지를 두고 src="img/my-cursor.png"로 사용 가능 */

    /* 버튼 등에서 pointer 커서 유지 */
    a, button, .social-button, label, .switch {
      cursor: pointer;
    }

    /* Password Modal Styles */
    #password-modal {
      /* ... (existing modal styles if any, or add new ones) ... */
      /* Ensure it's hidden by default if not already */
      display: none; 
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    #password-modal.active {
      display: flex;
    }
    #password-modal .modal-content {
      background-color: white;
      padding: 20px 40px;
      border-radius: 8px;
      text-align: center;
      position: relative; /* For close button positioning */
      color: #333;
    }
    .modal-close-btn {
      position: absolute;
      top: 10px;
      left: 15px;
      font-size: 24px;
      font-weight: bold;
      color: #888;
      cursor: pointer;
      line-height: 1;
    }
    .modal-close-btn:hover {
      color: #333;
    }

    /* Profile Image Blur */
    #profile-container .profile-img {
      filter: blur(8px); /* Initial blur */
      transition: filter 0.3s ease-in-out;
    }
    #profile-container.unblurred .profile-img {
      filter: blur(0px); /* No blur when 'unblurred' class is present */
    }
  </style>
  <script src="language-switcher.js"></script>
  <script src="load-nav.js" defer></script> <!-- load-nav.js 추가 -->
  <script>
    // 오버레이 애니메이션
    window.addEventListener('DOMContentLoaded', function() {
      const overlay = document.getElementById('site-overlay');
      setTimeout(() => {
        overlay.classList.add('hide');
      }, 400); // 약간의 딜레이 후 애니메이션 시작
      overlay.addEventListener('transitionend', () => {
        overlay.parentNode.removeChild(overlay);
      });
    });
  </script>
</head>
<body>
  <div id="nav-placeholder"></div> <!-- 기존 nav-menu를 placeholder로 대체 -->

  <!-- Background Canvas -->
  <canvas id="bg"></canvas>
  <!-- 오버레이 효과 -->
  <div id="site-overlay"></div>

  <!-- Password Modal -->
  <div id="password-modal">
    <div class="modal-content">
      <span class="modal-close-btn" id="modal-close-button">&times;</span>
      <p data-ja="パスワードを入力してください" data-ko="암호를 입력하세요">암호를 입력하세요</p>
      <input type="password" id="password-input" />
      <button id="password-submit" data-ja="確認" data-ko="확인">확인</button>
      <p id="password-error" style="color:red; display:none;" data-ja="パスワードが間違っています。" data-ko="암호가 틀렸습니다.">암호가 틀렸습니다.</p>
    </div>
  </div>
  
  <div class="main-layout">
    <div class="content">
      
      
      <!-- 큰 동그라미 추가 -->
      <div style="display: flex; justify-content: center; align-items: center; height: 320px; margin: 40px 0;">
        <div id="profile-container" style="
          width: 260px;
          height: 260px;
          border-radius: 50%;
          background: #fff;
          box-shadow: 0 4px 32px rgba(0,0,0,0.10);
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 2rem;
          color: #bbb;
          overflow: hidden;
        ">
          <!-- 
            아래 img 태그의 src에 사용할 이미지는 
            /Users/shin/Desktop/study/img/profile.jpg 와 같이 img 폴더를 만들어 저장하세요.
            예시: <img src="img/profile.jpg" alt="프로필 이미지" style="width:100%;height:100%;object-fit:cover;">
          -->
          <img src="img/profile.JPEG" alt="프로필 이미지" class="profile-img" style="width:100%;height:100%;object-fit:cover;">
        </div>
      </div>

      <!-- SHIN 텍스트 크게, 커스텀 폰트 적용 -->
      <div class="shin-title">
        SHIN
      </div>

      <!-- Sphere Effect -->
      <div id="sphere-area">
        <!-- 20 grey spheres -->
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
        <div class="sphere"></div>
      </div>
      <div class="social-links">
        <a rel="noopener" href="https://www.youtube.com/@tcu_vlog2215" class="social-button youtube" target="_blank" data-ja="ユーチューブ" data-ko="유튜브">
          <i class="fab fa-youtube"></i>
          YouTube
        </a>
        <a rel="noopener" href="https://www.instagram.com/utaenaimiku" class="social-button instagram" target="_blank" data-ja="インスタグラム" data-ko="인스타그램">
          <i class="fab fa-instagram"></i>
          Instagram
        </a>
        <a rel="noopener" href="https://twitter.com/sico_sico_sico_" class="social-button twitter" target="_blank" data-ja="𝕏" data-ko="𝕏">
          <i class="fab fa-x-twitter"></i>
          𝕏
        </a>

      </div>

      <!-- 언어 토글 버튼 (선택한 언어만 표시) -->
      <div class="language-switcher">
        <span class="language-label" id="current-lang">日本語</span>
        <label class="switch">
          <input aria-label="Language Toggle" type="checkbox" id="language-toggle">
          <span class="slider"></span>
        </label>
      </div>
    </div>
    <aside class="youtube-sidebar">
      <h2 id="youtube-title" data-ja="最新のYouTube動画" data-ko="최신 YouTube 동영상">最新のYouTube動画</h2>
      <div class="youtube-videos">
        <div class="youtube-section-title" id="latest-videos" data-ja="最新動画（최신영상）" data-ko="최신 동영상（最新動画）">最新動画（최신영상）</div>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/w8iq04de_RA" title="YouTube video 1" frameborder="0" allowfullscreen></iframe>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/7kz51n1eNtc" title="YouTube video 2" frameborder="0" allowfullscreen></iframe>
        <iframe width="100%" height="180" src="https://www.youtube.com/embed/09uETkRHY8k" title="YouTube video 3" frameborder="0" allowfullscreen></iframe>
      </div>
      <a rel="noopener" href="https://www.youtube.com/@tcu_vlog2215" target="_blank" class="youtube-more" id="more-link" data-ja="もっと見る" data-ko="더 보기">もっと見る</a>
    </aside>

  </div>

  <script>
    // 時計機能
    function updateClock() {
      const now = new Date();
      const hh = String(now.getHours()).padStart(2, '0');
      const mm = String(now.getMinutes()).padStart(2, '0');
      const ss = String(now.getSeconds()).padStart(2, '0');
      document.getElementById('clock').textContent = `${hh}:${mm}:${ss}`;
    }
    setInterval(updateClock, 1000);
    updateClock();

    // 背景キャンバスアニメーション
    const canvas = document.getElementById('bg');
    const ctx = canvas.getContext('2d');
    let mouseX = 0;
    let mouseY = 0;
    
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // 마우스 위치 추적
    document.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    // 어두운 남색 배경 + 손전등 효과로 변경
    function drawBackground() {
      // 어두운 남색 배경
      ctx.fillStyle = "#0a1733";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 손전등(라이트) 효과
      const flashlightRadius = 500;
      const gradient = ctx.createRadialGradient(
        mouseX, mouseY, 0,
        mouseX, mouseY, flashlightRadius
      );
      gradient.addColorStop(0, "rgba(255,255,255,0.18)");
      gradient.addColorStop(0.5, "rgba(255,255,255,0.08)");
      gradient.addColorStop(1, "rgba(10,23,51,0.0)");
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, flashlightRadius, 0, Math.PI * 2);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
      ctx.globalCompositeOperation = "source-over";
    }

    // 큰 원들 애니메이션
    const circles = [];
    const circleCount = 4; // 큰 원 개수 줄임
    
    class AnimatedCircle {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.vx = (Math.random() - 0.5) * 3; // 속도 증가
        this.vy = (Math.random() - 0.5) * 3; // 속도 증가
        this.baseSize = Math.random() * 150 + 100; // 큰 원 크기
        this.size = this.baseSize;
        this.opacity = 0.6;
        this.hue = Math.random() * 60 + 180; // 하늘색 계열 (180-240도)
      }
      
      update() {
        // 마우스와의 거리 계산
        const dx = mouseX - this.x;
        const dy = mouseY - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // 마우스가 가까우면 끌어당김
        if (distance < 200) {
          const force = (200 - distance) / 200 * 0.02;
          this.vx += (dx / distance) * force;
          this.vy += (dy / distance) * force;
          this.size = this.baseSize * (1 + force * 10);
        } else {
          this.size = this.baseSize;
        }
        
        // 속도 제한
        this.vx = Math.max(-3, Math.min(3, this.vx)); // 속도 제한 증가
        this.vy = Math.max(-3, Math.min(3, this.vy)); // 속도 제한 증가
        
        // 위치 업데이트
        this.x += this.vx;
        this.y += this.vy;
        
        // 경계에서 반사
        if (this.x < -this.size/2) {
          this.x = canvas.width + this.size/2;
        } else if (this.x > canvas.width + this.size/2) {
          this.x = -this.size/2;
        }
        
        if (this.y < -this.size/2) {
          this.y = canvas.height + this.size/2;
        } else if (this.y > canvas.height + this.size/2) {
          this.y = -this.size/2;
        }
        
        // 마찰력
        this.vx *= 0.99;
        this.vy *= 0.99;
      }
      
      draw() {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        // 그라디언트 원
        const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
        gradient.addColorStop(0, `hsla(${this.hue}, 80%, 50%, 0.8)`);
        gradient.addColorStop(0.7, `hsla(${this.hue}, 60%, 40%, 0.4)`);
        gradient.addColorStop(1, `hsla(${this.hue}, 40%, 30%, 0.1)`);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // 원들 생성
    for (let i = 0; i < circleCount; i++) {
      circles.push(new AnimatedCircle());
    }
    
    function animate() {
      // 배경 그리기
      drawBackground();
      
      // 원들 업데이트 및 그리기
      circles.forEach(circle => {
        circle.update();
        circle.draw();
      });
      
      requestAnimationFrame(animate);
    }
    animate();
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const area = document.getElementById('sphere-area');
      const spheres = area.querySelectorAll('.sphere');

      spheres.forEach(s => {
        // 위치가 퍼질 목표 지점
        const ang = Math.random() * Math.PI * 2;
        const rad = 120 + Math.random() * 60;
        s.dataset.tx = (Math.cos(ang) * rad).toFixed(1);
        s.dataset.ty = (Math.sin(ang) * rad).toFixed(1);

        // 초기 위치를 약간 흩어지게 설정
        const initAng = Math.random() * Math.PI * 2;
        const initRad = 20 + Math.random() * 30;
        s.dataset.ix = (Math.cos(initAng) * initRad).toFixed(1);
        s.dataset.iy = (Math.sin(initAng) * initRad).toFixed(1);

        // 부드러운 흔들림을 위한 파라미터
        s.dataset.fx = ((Math.random() - 0.5) * 10).toFixed(1);
        s.dataset.fy = ((Math.random() - 0.5) * 10).toFixed(1);
        s.dataset.fs = (2 + Math.random() * 3).toFixed(1); // 속도
      });

      let hover = false;
      area.addEventListener('mouseenter', () => (hover = true));
      area.addEventListener('mouseleave', () => (hover = false));

      function animate() {
        const t = Date.now() / 1000;
        spheres.forEach(s => {
          const baseX = hover ? parseFloat(s.dataset.tx) : parseFloat(s.dataset.ix);
          const baseY = hover ? parseFloat(s.dataset.ty) : parseFloat(s.dataset.iy);
          const floatX = parseFloat(s.dataset.fx) * Math.sin(t * s.dataset.fs);
          const floatY = parseFloat(s.dataset.fy) * Math.cos(t * s.dataset.fs);
          s.style.transform = `translate(calc(-50% + ${baseX + floatX}px), calc(-50% + ${baseY + floatY}px))`;
        });
        requestAnimationFrame(animate);
      }
      animate();
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', function () {
      const profileContainer = document.getElementById('profile-container');
      const modal = document.getElementById('password-modal');
      const passwordInput = document.getElementById('password-input');
      const passwordSubmit = document.getElementById('password-submit');
      const passwordError = document.getElementById('password-error');
      const modalCloseButton = document.getElementById('modal-close-button');

      // Ensure profile is blurred initially
      if (profileContainer) {
        profileContainer.classList.remove('unblurred');
      }

      function showPasswordModal() {
        if (profileContainer.classList.contains('unblurred')) {
          // If already unblurred, clicking again could re-blur or do nothing
          // For now, let's make it re-blur and require password again
          profileContainer.classList.remove('unblurred'); 
        }
        modal.classList.add('active');
        passwordInput.value = '';
        passwordError.style.display = 'none';
        passwordInput.focus();
      }

      function hidePasswordModal() {
        modal.classList.remove('active');
      }

      function checkPassword() {
        if (passwordInput.value === '0721') {
          hidePasswordModal();
          if (profileContainer) {
            profileContainer.classList.add('unblurred'); // Unblur the image
          }
        } else {
          passwordError.style.display = 'block';
          passwordInput.value = '';
          passwordInput.focus();
        }
      }

      if (profileContainer) {
        profileContainer.addEventListener('click', showPasswordModal);
      }
      
      if (passwordSubmit) {
        passwordSubmit.addEventListener('click', checkPassword);
      }

      if (passwordInput) {
        passwordInput.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            checkPassword();
          }
        });
      }
      
      if (modalCloseButton) {
        modalCloseButton.addEventListener('click', hidePasswordModal);
      }

      // Remove the direct toggle on profile click that bypassed password
      // The old problematic code was:
      // if (profile) {
      //   profile.addEventListener('click', function () {
      //     profile.classList.toggle('clicked'); // 'clicked' might be 'unblurred' now
      //   });
      // }
      // This is now correctly handled by showPasswordModal and checkPassword.
    });
  </script>
</body>
</html>
